<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Bignum - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Integer.html">Integer</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-25">#%</a>
    
    <li ><a href="#method-i-26">#&amp;</a>
    
    <li ><a href="#method-i-2A">#*</a>
    
    <li ><a href="#method-i-2A-2A">#**</a>
    
    <li ><a href="#method-i-2B">#+</a>
    
    <li ><a href="#method-i-2D">#-</a>
    
    <li ><a href="#method-i-2D-40">#-@</a>
    
    <li ><a href="#method-i-2F">#/</a>
    
    <li ><a href="#method-i-3C">#&lt;</a>
    
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    
    <li ><a href="#method-i-3C-3D">#&lt;=</a>
    
    <li ><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-3D-3D-3D">#===</a>
    
    <li ><a href="#method-i-3E">#&gt;</a>
    
    <li ><a href="#method-i-3E-3D">#&gt;=</a>
    
    <li ><a href="#method-i-3E-3E">#&gt;&gt;</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5E">#^</a>
    
    <li ><a href="#method-i-abs">#abs</a>
    
    <li ><a href="#method-i-bit_length">#bit_length</a>
    
    <li ><a href="#method-i-coerce">#coerce</a>
    
    <li ><a href="#method-i-div">#div</a>
    
    <li ><a href="#method-i-divmod">#divmod</a>
    
    <li ><a href="#method-i-eql-3F">#eql?</a>
    
    <li ><a href="#method-i-even-3F">#even?</a>
    
    <li ><a href="#method-i-fdiv">#fdiv</a>
    
    <li ><a href="#method-i-hash">#hash</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-magnitude">#magnitude</a>
    
    <li ><a href="#method-i-modulo">#modulo</a>
    
    <li ><a href="#method-i-odd-3F">#odd?</a>
    
    <li ><a href="#method-i-remainder">#remainder</a>
    
    <li ><a href="#method-i-size">#size</a>
    
    <li ><a href="#method-i-to_f">#to_f</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
    <li ><a href="#method-i-7C">#|</a>
    
    <li ><a href="#method-i-7E">#~</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Bignum">
  <h1 id="class-Bignum" class="class">
    class Bignum
  </h1>

  <section class="description">
    
<p><a href="Bignum.html">Bignum</a> objects hold integers outside the range of
<a href="Fixnum.html">Fixnum</a>. <a href="Bignum.html">Bignum</a> objects
are created automatically when integer calculations would otherwise
overflow a <a href="Fixnum.html">Fixnum</a>. When a calculation involving
<a href="Bignum.html">Bignum</a> objects returns a result that will fit in
a <a href="Fixnum.html">Fixnum</a>, the result is automatically converted.</p>

<p>For the purposes of the bitwise operations and <code>[]</code>, a <a
href="Bignum.html">Bignum</a> is treated as if it were an infinite-length
bitstring with 2&#39;s complement representation.</p>

<p>While <a href="Fixnum.html">Fixnum</a> values are immediate, <a
href="Bignum.html">Bignum</a> objects are not—assignment and parameter
passing work with references to objects, not the objects themselves.</p>

<p>When mathn is required Bignum&#39;s division is enhanced to return more
precise values from mathematical expressions.</p>

<pre class="ruby">(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">72</span>) <span class="ruby-operator">/</span> ((<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">70</span>) <span class="ruby-operator">*</span> <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 4/3</span>
</pre>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
      
        <dt id="GMP_VERSION">GMP_VERSION
        
        <dd><p>The version of loaded GMP.</p>
        
      
      </dl>
    </section>
    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-25" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big % other         &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns big modulo other. See <a
href="Numeric.html#method-i-divmod">Numeric#divmod</a> for more
information.</p>
          
          

          
          <div class="method-source-code" id="25-source">
            <pre>VALUE
rb_big_modulo(VALUE x, VALUE y)
{
    VALUE z;

    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (!RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bin(x, y, &#39;%&#39;);
    }
    bigdivmod(x, y, 0, &amp;z);

    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-26" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &amp; numeric   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Performs bitwise <code>and</code> between <em>big</em> and
<em>numeric</em>.</p>
          
          

          
          <div class="method-source-code" id="26-source">
            <pre>VALUE
rb_big_and(VALUE x, VALUE y)
{
    VALUE z;
    BDIGIT *ds1, *ds2, *zds;
    long i, xn, yn, n1, n2;
    BDIGIT hibitsx, hibitsy;
    BDIGIT hibits1, hibits2;
    VALUE tmpv;
    BDIGIT tmph;
    long tmpn;

    if (!FIXNUM_P(y) &amp;&amp; !RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bit(x, y, &#39;&amp;&#39;);
    }

    hibitsx = abs2twocomp(&amp;x, &amp;xn);
    if (FIXNUM_P(y)) {
        return bigand_int(x, xn, hibitsx, FIX2LONG(y));
    }
    hibitsy = abs2twocomp(&amp;y, &amp;yn);
    if (xn &gt; yn) {
        tmpv = x; x = y; y = tmpv;
        tmpn = xn; xn = yn; yn = tmpn;
        tmph = hibitsx; hibitsx = hibitsy; hibitsy = tmph;
    }
    n1 = xn;
    n2 = yn;
    ds1 = BDIGITS(x);
    ds2 = BDIGITS(y);
    hibits1 = hibitsx;
    hibits2 = hibitsy;

    if (!hibits1)
        n2 = n1;

    z = bignew(n2, 0);
    zds = BDIGITS(z);

    for (i=0; i&lt;n1; i++) {
        zds[i] = ds1[i] &amp; ds2[i];
    }
    for (; i&lt;n2; i++) {
        zds[i] = hibits1 &amp; ds2[i];
    }
    twocomp2abs_bang(z, hibits1 &amp;&amp; hibits2);
    RB_GC_GUARD(x);
    RB_GC_GUARD(y);
    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2A" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big * other  &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Multiplies big and other, returning the result.</p>
          
          

          
          <div class="method-source-code" id="2A-source">
            <pre>VALUE
rb_big_mul(VALUE x, VALUE y)
{
    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return DBL2NUM(rb_big2dbl(x) * RFLOAT_VALUE(y));
    }
    else {
        return rb_num_coerce_bin(x, y, &#39;*&#39;);
    }

    return bignorm(bigmul0(x, y));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2A-2A" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big ** exponent   &rarr; numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Raises <em>big</em> to the <em>exponent</em> power (which may be an
integer, float, or anything that will coerce to a number). The result may
be a <a href="Fixnum.html">Fixnum</a>, <a href="Bignum.html">Bignum</a>, or
<a href="Float.html">Float</a></p>

<pre class="ruby"><span class="ruby-value">123456789</span> <span class="ruby-operator">**</span> <span class="ruby-value">2</span>      <span class="ruby-comment">#=&gt; 15241578750190521</span>
<span class="ruby-value">123456789</span> <span class="ruby-operator">**</span> <span class="ruby-value">1.2</span>    <span class="ruby-comment">#=&gt; 5126464716.09932</span>
<span class="ruby-value">123456789</span> <span class="ruby-operator">**</span> <span class="ruby-value">-2</span>     <span class="ruby-comment">#=&gt; 6.5610001194102e-17</span>
</pre>
          
          

          
          <div class="method-source-code" id="2A-2A-source">
            <pre>VALUE
rb_big_pow(VALUE x, VALUE y)
{
    double d;
    SIGNED_VALUE yy;

  again:
    if (y == INT2FIX(0)) return INT2FIX(1);
    if (RB_FLOAT_TYPE_P(y)) {
        d = RFLOAT_VALUE(y);
        if ((!BIGNUM_SIGN(x) &amp;&amp; !BIGZEROP(x)) &amp;&amp; d != round(d))
            return rb_funcall(rb_complex_raw1(x), rb_intern(&quot;**&quot;), 1, y);
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
        y = bignorm(y);
        if (FIXNUM_P(y))
            goto again;
        rb_warn(&quot;in a**b, b may be too big&quot;);
        d = rb_big2dbl(y);
    }
    else if (FIXNUM_P(y)) {
        yy = FIX2LONG(y);

        if (yy &lt; 0)
            return rb_funcall(rb_rational_raw1(x), rb_intern(&quot;**&quot;), 1, y);
        else {
            VALUE z = 0;
            SIGNED_VALUE mask;
            const size_t xbits = rb_absint_numwords(x, 1, NULL);
            const size_t BIGLEN_LIMIT = 32*1024*1024;

            if (xbits == (size_t)-1 ||
                (xbits &gt; BIGLEN_LIMIT) ||
                (xbits * yy &gt; BIGLEN_LIMIT)) {
                rb_warn(&quot;in a**b, b may be too big&quot;);
                d = (double)yy;
            }
            else {
                for (mask = FIXNUM_MAX + 1; mask; mask &gt;&gt;= 1) {
                    if (z) z = bigsq(z);
                    if (yy &amp; mask) {
                        z = z ? bigtrunc(bigmul0(z, x)) : x;
                    }
                }
                return bignorm(z);
            }
        }
    }
    else {
        return rb_num_coerce_bin(x, y, rb_intern(&quot;**&quot;));
    }
    return DBL2NUM(pow(rb_big2dbl(x), d));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2B" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big + other  &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Adds big and other, returning the result.</p>
          
          

          
          <div class="method-source-code" id="2B-source">
            <pre>VALUE
rb_big_plus(VALUE x, VALUE y)
{
    long n;

    if (FIXNUM_P(y)) {
        n = FIX2LONG(y);
        if ((n &gt; 0) != BIGNUM_SIGN(x)) {
            if (n &lt; 0) {
                n = -n;
            }
            return bigsub_int(x, n);
        }
        if (n &lt; 0) {
            n = -n;
        }
        return bigadd_int(x, n);
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
        return bignorm(bigadd(x, y, 1));
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return DBL2NUM(rb_big2dbl(x) + RFLOAT_VALUE(y));
    }
    else {
        return rb_num_coerce_bin(x, y, &#39;+&#39;);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big - other  &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Subtracts other from big, returning the result.</p>
          
          

          
          <div class="method-source-code" id="2D-source">
            <pre>VALUE
rb_big_minus(VALUE x, VALUE y)
{
    long n;

    if (FIXNUM_P(y)) {
        n = FIX2LONG(y);
        if ((n &gt; 0) != BIGNUM_SIGN(x)) {
            if (n &lt; 0) {
                n = -n;
            }
            return bigadd_int(x, n);
        }
        if (n &lt; 0) {
            n = -n;
        }
        return bigsub_int(x, n);
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
        return bignorm(bigadd(x, y, 0));
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return DBL2NUM(rb_big2dbl(x) - RFLOAT_VALUE(y));
    }
    else {
        return rb_num_coerce_bin(x, y, &#39;-&#39;);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2D-40" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            -big   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Unary minus (returns an integer whose value is 0-big)</p>
          
          

          
          <div class="method-source-code" id="2D-40-source">
            <pre>VALUE
rb_big_uminus(VALUE x)
{
    VALUE z = rb_big_clone(x);

    BIGNUM_SET_SIGN(z, !BIGNUM_SIGN(x));

    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-2F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big / other     &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Performs division: the class of the resulting object depends on the class
of <code>numeric</code> and on the magnitude of the result.</p>
          
          

          
          <div class="method-source-code" id="2F-source">
            <pre>VALUE
rb_big_div(VALUE x, VALUE y)
{
    return rb_big_divide(x, y, &#39;/&#39;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &lt; real  &rarr;  true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the value of <code>big</code> is less than
that of <code>real</code>.</p>
          
          

          
          <div class="method-source-code" id="3C-source">
            <pre>static VALUE
big_lt(VALUE x, VALUE y)
{
    return big_op(x, y, big_op_lt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3C" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &lt;&lt; numeric   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shifts big left <em>numeric</em> positions (right if <em>numeric</em> is
negative).</p>
          
          

          
          <div class="method-source-code" id="3C-3C-source">
            <pre>VALUE
rb_big_lshift(VALUE x, VALUE y)
{
    int lshift_p;
    size_t shift_numdigits;
    int shift_numbits;

    for (;;) {
        if (FIXNUM_P(y)) {
            long l = FIX2LONG(y);
            unsigned long shift;
            if (0 &lt;= l) {
                lshift_p = 1;
                shift = l;
            }
            else {
                lshift_p = 0;
                shift = 1+(unsigned long)(-(l+1));
            }
            shift_numbits = (int)(shift &amp; (BITSPERDIG-1));
            shift_numdigits = shift &gt;&gt; bit_length(BITSPERDIG-1);
            return bignorm(big_shift3(x, lshift_p, shift_numdigits, shift_numbits));
        }
        else if (RB_BIGNUM_TYPE_P(y)) {
            return bignorm(big_shift2(x, 1, y));
        }
        y = rb_to_int(y);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &lt;= real  &rarr;  true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the value of <code>big</code> is less than or
equal to that of <code>real</code>.</p>
          
          

          
          <div class="method-source-code" id="3C-3D-source">
            <pre>static VALUE
big_le(VALUE x, VALUE y)
{
    return big_op(x, y, big_op_le);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3C-3D-3E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &lt;=&gt; numeric   &rarr; -1, 0, +1 or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Comparison—Returns -1, 0, or +1 depending on whether <code>big</code> is
less than, equal to, or greater than <code>numeric</code>. This is the
basis for the tests in <a href="Comparable.html">Comparable</a>.</p>

<p><code>nil</code> is returned if the two values are incomparable.</p>
          
          

          
          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>VALUE
rb_big_cmp(VALUE x, VALUE y)
{
    int cmp;

    if (FIXNUM_P(y)) {
        x = bignorm(x);
        if (FIXNUM_P(x)) {
            if (FIX2LONG(x) &gt; FIX2LONG(y)) return INT2FIX(1);
            if (FIX2LONG(x) &lt; FIX2LONG(y)) return INT2FIX(-1);
            return INT2FIX(0);
        }
        else {
            if (BIGNUM_NEGATIVE_P(x)) return INT2FIX(-1);
            return INT2FIX(1);
        }
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return rb_integer_float_cmp(x, y);
    }
    else {
        return rb_num_coerce_cmp(x, y, rb_intern(&quot;&lt;=&gt;&quot;));
    }

    if (BIGNUM_SIGN(x) &gt; BIGNUM_SIGN(y)) return INT2FIX(1);
    if (BIGNUM_SIGN(x) &lt; BIGNUM_SIGN(y)) return INT2FIX(-1);

    cmp = bary_cmp(BDIGITS(x), BIGNUM_LEN(x), BDIGITS(y), BIGNUM_LEN(y));
    if (BIGNUM_SIGN(x))
        return INT2FIX(cmp);
    else
        return INT2FIX(-cmp);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big == obj  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> only if <em>obj</em> has the same value as
<em>big</em>. Contrast this with <code>Bignum#eql?</code>, which requires
<em>obj</em> to be a <code>Bignum</code>.</p>

<pre class="ruby"><span class="ruby-value">68719476736</span> <span class="ruby-operator">==</span> <span class="ruby-value">68719476736.0</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>VALUE
rb_big_eq(VALUE x, VALUE y)
{
    if (FIXNUM_P(y)) {
        if (bignorm(x) == y) return Qtrue;
        y = rb_int2big(FIX2LONG(y));
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return rb_integer_float_eq(x, y);
    }
    else {
        return rb_equal(y, x);
    }
    if (BIGNUM_SIGN(x) != BIGNUM_SIGN(y)) return Qfalse;
    if (BIGNUM_LEN(x) != BIGNUM_LEN(y)) return Qfalse;
    if (MEMCMP(BDIGITS(x),BDIGITS(y),BDIGIT,BIGNUM_LEN(y)) != 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3D-3D-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big == obj  &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> only if <em>obj</em> has the same value as
<em>big</em>. Contrast this with <code>Bignum#eql?</code>, which requires
<em>obj</em> to be a <code>Bignum</code>.</p>

<pre class="ruby"><span class="ruby-value">68719476736</span> <span class="ruby-operator">==</span> <span class="ruby-value">68719476736.0</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
          
          

          
          <div class="method-source-code" id="3D-3D-3D-source">
            <pre>VALUE
rb_big_eq(VALUE x, VALUE y)
{
    if (FIXNUM_P(y)) {
        if (bignorm(x) == y) return Qtrue;
        y = rb_int2big(FIX2LONG(y));
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        return rb_integer_float_eq(x, y);
    }
    else {
        return rb_equal(y, x);
    }
    if (BIGNUM_SIGN(x) != BIGNUM_SIGN(y)) return Qfalse;
    if (BIGNUM_LEN(x) != BIGNUM_LEN(y)) return Qfalse;
    if (MEMCMP(BDIGITS(x),BDIGITS(y),BDIGIT,BIGNUM_LEN(y)) != 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &gt; real  &rarr;  true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the value of <code>big</code> is greater than
that of <code>real</code>.</p>
          
          

          
          <div class="method-source-code" id="3E-source">
            <pre>static VALUE
big_gt(VALUE x, VALUE y)
{
    return big_op(x, y, big_op_gt);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3E-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &gt;= real  &rarr;  true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if the value of <code>big</code> is greater than
or equal to that of <code>real</code>.</p>
          
          

          
          <div class="method-source-code" id="3E-3D-source">
            <pre>static VALUE
big_ge(VALUE x, VALUE y)
{
    return big_op(x, y, big_op_ge);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-3E-3E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big &gt;&gt; numeric   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shifts big right <em>numeric</em> positions (left if <em>numeric</em> is
negative).</p>
          
          

          
          <div class="method-source-code" id="3E-3E-source">
            <pre>VALUE
rb_big_rshift(VALUE x, VALUE y)
{
    int lshift_p;
    size_t shift_numdigits;
    int shift_numbits;

    for (;;) {
        if (FIXNUM_P(y)) {
            long l = FIX2LONG(y);
            unsigned long shift;
            if (0 &lt;= l) {
                lshift_p = 0;
                shift = l;
            }
            else {
                lshift_p = 1;
                shift = 1+(unsigned long)(-(l+1));
            }
            shift_numbits = (int)(shift &amp; (BITSPERDIG-1));
            shift_numdigits = shift &gt;&gt; bit_length(BITSPERDIG-1);
            return bignorm(big_shift3(x, lshift_p, shift_numdigits, shift_numbits));
        }
        else if (RB_BIGNUM_TYPE_P(y)) {
            return bignorm(big_shift2(x, 0, y));
        }
        y = rb_to_int(y);
    }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big[n] &rarr; 0, 1
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Bit Reference—Returns the <em>n</em>th bit in the (assumed) binary
representation of <em>big</em>, where <em><a href="0">big</a></em> is the
least significant bit.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">9</span><span class="ruby-operator">**</span><span class="ruby-value">15</span>
<span class="ruby-value">50</span>.<span class="ruby-identifier">downto</span>(<span class="ruby-value">0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">print</span> <span class="ruby-identifier">a</span>[<span class="ruby-identifier">n</span>]
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-value">000101110110100000111000011110010100111100010111001</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_big_aref(VALUE x, VALUE y)
{
    BDIGIT *xds;
    size_t shift;
    size_t i, s1, s2;
    long l;
    BDIGIT bit;

    if (RB_BIGNUM_TYPE_P(y)) {
        if (!BIGNUM_SIGN(y))
            return INT2FIX(0);
        bigtrunc(y);
        if (BIGSIZE(y) &gt; sizeof(size_t)) {
          out_of_range:
            return BIGNUM_SIGN(x) ? INT2FIX(0) : INT2FIX(1);
        }
#if SIZEOF_SIZE_T &lt;= SIZEOF_LONG
        shift = big2ulong(y, &quot;long&quot;);
#else
        shift = big2ull(y, &quot;long long&quot;);
#endif
    }
    else {
        l = NUM2LONG(y);
        if (l &lt; 0) return INT2FIX(0);
        shift = (size_t)l;
    }
    s1 = shift/BITSPERDIG;
    s2 = shift%BITSPERDIG;
    bit = (BDIGIT)1 &lt;&lt; s2;

    if (s1 &gt;= BIGNUM_LEN(x)) goto out_of_range;

    xds = BDIGITS(x);
    if (BIGNUM_POSITIVE_P(x))
        return (xds[s1] &amp; bit) ? INT2FIX(1) : INT2FIX(0);
    if (xds[s1] &amp; (bit-1))
        return (xds[s1] &amp; bit) ? INT2FIX(0) : INT2FIX(1);
    for (i = 0; i &lt; s1; i++)
        if (xds[i])
            return (xds[s1] &amp; bit) ? INT2FIX(0) : INT2FIX(1);
    return (xds[s1] &amp; bit) ? INT2FIX(1) : INT2FIX(0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big ^ numeric   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Performs bitwise +exclusive or+ between <em>big</em> and <em>numeric</em>.</p>
          
          

          
          <div class="method-source-code" id="5E-source">
            <pre>VALUE
rb_big_xor(VALUE x, VALUE y)
{
    VALUE z;
    BDIGIT *ds1, *ds2, *zds;
    long i, xn, yn, n1, n2;
    BDIGIT hibitsx, hibitsy;
    BDIGIT hibits1, hibits2;
    VALUE tmpv;
    BDIGIT tmph;
    long tmpn;

    if (!FIXNUM_P(y) &amp;&amp; !RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bit(x, y, &#39;^&#39;);
    }

    hibitsx = abs2twocomp(&amp;x, &amp;xn);
    if (FIXNUM_P(y)) {
        return bigxor_int(x, xn, hibitsx, FIX2LONG(y));
    }
    hibitsy = abs2twocomp(&amp;y, &amp;yn);
    if (xn &gt; yn) {
        tmpv = x; x = y; y = tmpv;
        tmpn = xn; xn = yn; yn = tmpn;
        tmph = hibitsx; hibitsx = hibitsy; hibitsy = tmph;
    }
    n1 = xn;
    n2 = yn;
    ds1 = BDIGITS(x);
    ds2 = BDIGITS(y);
    hibits1 = hibitsx;
    hibits2 = hibitsy;

    z = bignew(n2, 0);
    zds = BDIGITS(z);

    for (i=0; i&lt;n1; i++) {
        zds[i] = ds1[i] ^ ds2[i];
    }
    for (; i&lt;n2; i++) {
        zds[i] = hibitsx ^ ds2[i];
    }
    twocomp2abs_bang(z, (hibits1 ^ hibits2) != 0);
    RB_GC_GUARD(x);
    RB_GC_GUARD(y);
    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs &rarr; aBignum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the absolute value of <em>big</em>.</p>

<pre class="ruby"><span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">abs</span>   <span class="ruby-comment">#=&gt; 1234567890987654321</span>
</pre>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre>static VALUE
rb_big_abs(VALUE x)
{
    if (!BIGNUM_SIGN(x)) {
        x = rb_big_clone(x);
        BIGNUM_SET_SIGN(x, 1);
    }
    return x;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-bit_length" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            bit_length &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of bits of the value of <em>int</em>.</p>

<p>“the number of bits” means that the bit position of the highest bit which
is different to the sign bit. (The bit position of the bit 2**n is n+1.) If
there is no such bit (zero or minus one), zero is returned.</p>

<p>I.e. This method returns ceil(log2(int &lt; 0 ? -int : int+1)).</p>

<pre class="ruby">(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>  <span class="ruby-comment">#=&gt; 10001</span>
(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span>).<span class="ruby-identifier">bit_length</span>    <span class="ruby-comment">#=&gt; 10000</span>
(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>  <span class="ruby-comment">#=&gt; 10000</span>

(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>   <span class="ruby-comment">#=&gt; 1001</span>
(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span>).<span class="ruby-identifier">bit_length</span>     <span class="ruby-comment">#=&gt; 1000</span>
(<span class="ruby-value">-2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>   <span class="ruby-comment">#=&gt; 1000</span>

(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>    <span class="ruby-comment">#=&gt; 1000</span>
(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span>).<span class="ruby-identifier">bit_length</span>      <span class="ruby-comment">#=&gt; 1001</span>
(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">1000</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>    <span class="ruby-comment">#=&gt; 1001</span>

(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>   <span class="ruby-comment">#=&gt; 10000</span>
(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span>).<span class="ruby-identifier">bit_length</span>     <span class="ruby-comment">#=&gt; 10001</span>
(<span class="ruby-value">2</span><span class="ruby-operator">**</span><span class="ruby-value">10000</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>).<span class="ruby-identifier">bit_length</span>   <span class="ruby-comment">#=&gt; 10001</span>
</pre>

<p>This method can be used to detect overflow in <a
href="Array.html#method-i-pack">Array#pack</a> as follows.</p>

<pre class="ruby"><span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">bit_length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">32</span>
  [<span class="ruby-identifier">n</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-string">&quot;l&quot;</span>) <span class="ruby-comment"># no overflow</span>
<span class="ruby-keyword">else</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;overflow&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
          
          

          
          <div class="method-source-code" id="bit_length-source">
            <pre>static VALUE
rb_big_bit_length(VALUE big)
{
    int nlz_bits;
    size_t numbytes;

    static const BDIGIT char_bit[1] = { CHAR_BIT };
    BDIGIT numbytes_bary[bdigit_roomof(sizeof(size_t))];
    BDIGIT nlz_bary[1];
    BDIGIT result_bary[bdigit_roomof(sizeof(size_t)+1)];

    numbytes = rb_absint_size(big, &amp;nlz_bits);

    if (numbytes == 0)
        return LONG2FIX(0);

    if (BIGNUM_NEGATIVE_P(big) &amp;&amp; rb_absint_singlebit_p(big)) {
        if (nlz_bits != CHAR_BIT-1) {
            nlz_bits++;
        }
        else {
            nlz_bits = 0;
            numbytes--;
        }
    }

    if (numbytes &lt;= SIZE_MAX / CHAR_BIT) {
        return SIZET2NUM(numbytes * CHAR_BIT - nlz_bits);
    }

    nlz_bary[0] = nlz_bits;

    bary_unpack(BARY_ARGS(numbytes_bary), &amp;numbytes, 1, sizeof(numbytes), 0,
            INTEGER_PACK_NATIVE_BYTE_ORDER);
    BARY_SHORT_MUL(result_bary, numbytes_bary, char_bit);
    BARY_SUB(result_bary, result_bary, nlz_bary);

    return rb_integer_unpack(result_bary, numberof(result_bary), sizeof(BDIGIT), 0,
            INTEGER_PACK_LSWORD_FIRST|INTEGER_PACK_NATIVE_BYTE_ORDER);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-coerce" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            coerce(numeric)  &rarr;  array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array with both a <code>numeric</code> and a <code>big</code>
represented as <a href="Bignum.html">Bignum</a> objects.</p>

<p>This is achieved by converting <code>numeric</code> to a <a
href="Bignum.html">Bignum</a>.</p>

<p>A <a href="TypeError.html">TypeError</a> is raised if the
<code>numeric</code> is not a <a href="Fixnum.html">Fixnum</a> or <a
href="Bignum.html">Bignum</a> type.</p>

<pre class="ruby">(<span class="ruby-value">0x3FFFFFFFFFFFFFFF</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>).<span class="ruby-identifier">coerce</span>(<span class="ruby-value">42</span>)   <span class="ruby-comment">#=&gt; [42, 4611686018427387904]</span>
</pre>
          
          

          
          <div class="method-source-code" id="coerce-source">
            <pre>static VALUE
rb_big_coerce(VALUE x, VALUE y)
{
    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (!RB_BIGNUM_TYPE_P(y)) {
        rb_raise(rb_eTypeError, &quot;can&#39;t coerce %&quot;PRIsVALUE&quot; to Bignum&quot;,
                 rb_obj_class(y));
    }
    return rb_assoc_new(y, x);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-div" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            div(other)  &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Performs integer division: returns integer value.</p>
          
          

          
          <div class="method-source-code" id="div-source">
            <pre>VALUE
rb_big_idiv(VALUE x, VALUE y)
{
    return rb_big_divide(x, y, rb_intern(&quot;div&quot;));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-divmod" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            divmod(numeric)   &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>See <code>Numeric#divmod</code>.</p>
          
          

          
          <div class="method-source-code" id="divmod-source">
            <pre>VALUE
rb_big_divmod(VALUE x, VALUE y)
{
    VALUE div, mod;

    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (!RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bin(x, y, rb_intern(&quot;divmod&quot;));
    }
    bigdivmod(x, y, &amp;div, &amp;mod);

    return rb_assoc_new(bignorm(div), bignorm(mod));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eql-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eql?(obj)   &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> only if <em>obj</em> is a <code>Bignum</code>
with the same value as <em>big</em>. Contrast this with
<code>Bignum#==</code>, which performs type conversions.</p>

<pre class="ruby"><span class="ruby-value">68719476736</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-value">68719476736.0</span>)   <span class="ruby-comment">#=&gt; false</span>
</pre>
          
          

          
          <div class="method-source-code" id="eql-3F-source">
            <pre>VALUE
rb_big_eql(VALUE x, VALUE y)
{
    if (!RB_BIGNUM_TYPE_P(y)) return Qfalse;
    if (BIGNUM_SIGN(x) != BIGNUM_SIGN(y)) return Qfalse;
    if (BIGNUM_LEN(x) != BIGNUM_LEN(y)) return Qfalse;
    if (MEMCMP(BDIGITS(x),BDIGITS(y),BDIGIT,BIGNUM_LEN(y)) != 0) return Qfalse;
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-even-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            even? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>big</em> is an even number.</p>
          
          

          
          <div class="method-source-code" id="even-3F-source">
            <pre>static VALUE
rb_big_even_p(VALUE num)
{
    if (BIGNUM_LEN(num) != 0 &amp;&amp; BDIGITS(num)[0] &amp; 1) {
        return Qfalse;
    }
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fdiv" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fdiv(numeric) &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the floating point result of dividing <em>big</em> by
<em>numeric</em>.</p>

<pre class="ruby"><span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">fdiv</span>(<span class="ruby-value">13731</span>)      <span class="ruby-comment">#=&gt; -89910996357705.5</span>
<span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">fdiv</span>(<span class="ruby-value">13731.24</span>)   <span class="ruby-comment">#=&gt; -89909424858035.7</span>
</pre>
          
          

          
          <div class="method-source-code" id="fdiv-source">
            <pre>VALUE
rb_big_fdiv(VALUE x, VALUE y)
{
    double dx, dy;

    dx = big2dbl(x);
    if (FIXNUM_P(y)) {
        dy = (double)FIX2LONG(y);
        if (isinf(dx))
            return big_fdiv_int(x, rb_int2big(FIX2LONG(y)));
    }
    else if (RB_BIGNUM_TYPE_P(y)) {
        dy = rb_big2dbl(y);
        if (isinf(dx) || isinf(dy))
            return big_fdiv_int(x, y);
    }
    else if (RB_FLOAT_TYPE_P(y)) {
        dy = RFLOAT_VALUE(y);
        if (isnan(dy))
            return y;
        if (isinf(dx))
            return big_fdiv_float(x, y);
    }
    else {
        return rb_num_coerce_bin(x, y, rb_intern(&quot;fdiv&quot;));
    }
    return DBL2NUM(dx / dy);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hash   &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute a hash based on the value of <em>big</em>.</p>

<p>See also <a href="Object.html#method-i-hash">Object#hash</a>.</p>
          
          

          
          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
rb_big_hash(VALUE x)
{
    st_index_t hash;

    hash = rb_memhash(BDIGITS(x), sizeof(BDIGIT)*BIGNUM_LEN(x)) ^ BIGNUM_SIGN(x);
    return INT2FIX(hash);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inspect</span><span
            class="method-args">(p1 = v1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Bignum.html#method-i-to_s">to_s</a>
        </div>
        
      </div>

    
      <div id="method-i-magnitude" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            magnitude &rarr; aBignum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the absolute value of <em>big</em>.</p>

<pre class="ruby"><span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">abs</span>   <span class="ruby-comment">#=&gt; 1234567890987654321</span>
</pre>
          
          

          
          <div class="method-source-code" id="magnitude-source">
            <pre>static VALUE
rb_big_abs(VALUE x)
{
    if (!BIGNUM_SIGN(x)) {
        x = rb_big_clone(x);
        BIGNUM_SET_SIGN(x, 1);
    }
    return x;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-modulo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            modulo(other)   &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns big modulo other. See <a
href="Numeric.html#method-i-divmod">Numeric#divmod</a> for more
information.</p>
          
          

          
          <div class="method-source-code" id="modulo-source">
            <pre>VALUE
rb_big_modulo(VALUE x, VALUE y)
{
    VALUE z;

    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (!RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bin(x, y, &#39;%&#39;);
    }
    bigdivmod(x, y, 0, &amp;z);

    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-odd-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            odd? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns <code>true</code> if <em>big</em> is an odd number.</p>
          
          

          
          <div class="method-source-code" id="odd-3F-source">
            <pre>static VALUE
rb_big_odd_p(VALUE num)
{
    if (BIGNUM_LEN(num) != 0 &amp;&amp; BDIGITS(num)[0] &amp; 1) {
        return Qtrue;
    }
    return Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-remainder" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            remainder(numeric)    &rarr; number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the remainder after dividing <em>big</em> by <em>numeric</em>.</p>

<pre class="ruby"><span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">remainder</span>(<span class="ruby-value">13731</span>)      <span class="ruby-comment">#=&gt; -6966</span>
<span class="ruby-value">-1234567890987654321</span>.<span class="ruby-identifier">remainder</span>(<span class="ruby-value">13731.24</span>)   <span class="ruby-comment">#=&gt; -9906.22531493148</span>
</pre>
          
          

          
          <div class="method-source-code" id="remainder-source">
            <pre>static VALUE
rb_big_remainder(VALUE x, VALUE y)
{
    VALUE z;

    if (FIXNUM_P(y)) {
        y = rb_int2big(FIX2LONG(y));
    }
    else if (!RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bin(x, y, rb_intern(&quot;remainder&quot;));
    }
    bigdivrem(x, y, 0, &amp;z);

    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-size" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            size &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of bytes in the machine representation of <em>big</em>.</p>

<pre class="ruby">(<span class="ruby-value">256</span><span class="ruby-operator">**</span><span class="ruby-value">10</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">size</span>   <span class="ruby-comment">#=&gt; 12</span>
(<span class="ruby-value">256</span><span class="ruby-operator">**</span><span class="ruby-value">20</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">size</span>   <span class="ruby-comment">#=&gt; 20</span>
(<span class="ruby-value">256</span><span class="ruby-operator">**</span><span class="ruby-value">40</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">size</span>   <span class="ruby-comment">#=&gt; 40</span>
</pre>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre>static VALUE
rb_big_size(VALUE big)
{
    return SIZET2NUM(BIGSIZE(big));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_f" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_f &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts <em>big</em> to a <code>Float</code>. If <em>big</em> doesn&#39;t
fit in a <code>Float</code>, the result is infinity.</p>
          
          

          
          <div class="method-source-code" id="to_f-source">
            <pre>static VALUE
rb_big_to_f(VALUE x)
{
    return DBL2NUM(rb_big2dbl(x));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s(base=10)   &rarr;  string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a string containing the representation of <em>big</em> radix
<em>base</em> (2 through 36).</p>

<pre class="ruby"><span class="ruby-value">12345654321</span>.<span class="ruby-identifier">to_s</span>         <span class="ruby-comment">#=&gt; &quot;12345654321&quot;</span>
<span class="ruby-value">12345654321</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-value">2</span>)      <span class="ruby-comment">#=&gt; &quot;1011011111110110111011110000110001&quot;</span>
<span class="ruby-value">12345654321</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-value">8</span>)      <span class="ruby-comment">#=&gt; &quot;133766736061&quot;</span>
<span class="ruby-value">12345654321</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-value">16</span>)     <span class="ruby-comment">#=&gt; &quot;2dfdbbc31&quot;</span>
<span class="ruby-value">78546939656932</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-value">36</span>)  <span class="ruby-comment">#=&gt; &quot;rubyrules&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE
rb_big_to_s(int argc, VALUE *argv, VALUE x)
{
    int base;

    if (argc == 0) base = 10;
    else {
        VALUE b;

        rb_scan_args(argc, argv, &quot;01&quot;, &amp;b);
        base = NUM2INT(b);
    }
    return rb_big2str(x, base);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Bignum.html#method-i-inspect">inspect</a>
        </div>
        

        
      </div>

    
      <div id="method-i-7C" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            big | numeric   &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Performs bitwise <code>or</code> between <em>big</em> and <em>numeric</em>.</p>
          
          

          
          <div class="method-source-code" id="7C-source">
            <pre>VALUE
rb_big_or(VALUE x, VALUE y)
{
    VALUE z;
    BDIGIT *ds1, *ds2, *zds;
    long i, xn, yn, n1, n2;
    BDIGIT hibitsx, hibitsy;
    BDIGIT hibits1, hibits2;
    VALUE tmpv;
    BDIGIT tmph;
    long tmpn;

    if (!FIXNUM_P(y) &amp;&amp; !RB_BIGNUM_TYPE_P(y)) {
        return rb_num_coerce_bit(x, y, &#39;|&#39;);
    }

    hibitsx = abs2twocomp(&amp;x, &amp;xn);
    if (FIXNUM_P(y)) {
        return bigor_int(x, xn, hibitsx, FIX2LONG(y));
    }
    hibitsy = abs2twocomp(&amp;y, &amp;yn);
    if (xn &gt; yn) {
        tmpv = x; x = y; y = tmpv;
        tmpn = xn; xn = yn; yn = tmpn;
        tmph = hibitsx; hibitsx = hibitsy; hibitsy = tmph;
    }
    n1 = xn;
    n2 = yn;
    ds1 = BDIGITS(x);
    ds2 = BDIGITS(y);
    hibits1 = hibitsx;
    hibits2 = hibitsy;

    if (hibits1)
        n2 = n1;

    z = bignew(n2, 0);
    zds = BDIGITS(z);

    for (i=0; i&lt;n1; i++) {
        zds[i] = ds1[i] | ds2[i];
    }
    for (; i&lt;n2; i++) {
        zds[i] = hibits1 | ds2[i];
    }
    twocomp2abs_bang(z, hibits1 || hibits2);
    RB_GC_GUARD(x);
    RB_GC_GUARD(y);
    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-7E" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ~big  &rarr;  integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Inverts the bits in big. As Bignums are conceptually infinite length, the
result acts as if it had an infinite number of one bits to the left. In hex
representations, this is displayed as two periods to the left of the
digits.</p>

<pre class="ruby"><span class="ruby-identifier">sprintf</span>(<span class="ruby-string">&quot;%X&quot;</span>, <span class="ruby-operator">~</span><span class="ruby-value">0x1122334455</span>)    <span class="ruby-comment">#=&gt; &quot;..FEEDDCCBBAA&quot;</span>
</pre>
          
          

          
          <div class="method-source-code" id="7E-source">
            <pre>static VALUE
rb_big_neg(VALUE x)
{
    VALUE z = rb_big_clone(x);
    BDIGIT *ds = BDIGITS(z);
    long n = BIGNUM_LEN(z);

    if (!n) return INT2FIX(-1);

    if (BIGNUM_POSITIVE_P(z)) {
        if (bary_add_one(ds, n)) {
            big_extend_carry(z);
        }
        BIGNUM_SET_NEGATIVE_SIGN(z);
    }
    else {
        bary_neg(ds, n);
        if (bary_add_one(ds, n))
            return INT2FIX(-1);
        bary_neg(ds, n);
        BIGNUM_SET_POSITIVE_SIGN(z);
    }

    return bignorm(z);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

